<<<<<<< SEARCH
export const signBip322Message = async (
    message: string,
    vaultOrSeed: string | Uint8Array,
    pin?: string
): Promise<string> => {
    // 1. Get Pubkey from Enclave
    // We need the pubkey to construct the script code and P2WPKH output
    const signReq: SignRequest = {
        type: 'bip322',
        layer: 'Mainnet',
        payload: { network: 'mainnet' }, // Dummy payload to get pubkey
        description: 'BIP-322 Authentication'
    };

    // This initial call might prompt for biometric/PIN if not cached,
    // but primarily we need the pubkey first.
    // In optimized flow, we might cache pubkey in state to avoid this roundtrip.
    const identity = await requestEnclaveSignature(signReq, vaultOrSeed, pin);
    const pubkey = Buffer.from(identity.pubkey, 'hex');

    // Step 1: Build the message hash per BIP-322
    const tag = bitcoin.crypto.sha256(Buffer.from('BIP0322-signed-message'));
    const msgBuf = Buffer.from(message, 'utf8');
    const taggedHash = bitcoin.crypto.sha256(Buffer.concat([tag, tag, msgBuf]));

    // Step 2: Build virtual "to_spend" transaction
    const toSpendScriptSig = Buffer.concat([
      Buffer.from([0x00, 0x20]),  // OP_0 PUSH32
      taggedHash
    ]);

    const p2wpkh = bitcoin.payments.p2wpkh({ pubkey, network: bitcoin.networks.bitcoin });
    if (!p2wpkh.output) throw new Error('BIP-322: Failed to create P2WPKH output');

    const toSpendTx = new bitcoin.Transaction();
    toSpendTx.version = 0;
    toSpendTx.locktime = 0;
    toSpendTx.addInput(Buffer.alloc(32, 0), 0xFFFFFFFF, 0, toSpendScriptSig);
    toSpendTx.addOutput(p2wpkh.output, BigInt(0));

    // Step 3: Build "to_sign" transaction
    const toSignTx = new bitcoin.Transaction();
    toSignTx.version = 0;
    toSignTx.locktime = 0;
    toSignTx.addInput(toSpendTx.getHash(), 0, 0);
    toSignTx.addOutput(Buffer.from([0x6a]), BigInt(0)); // OP_RETURN

    // Step 4: Calculate Sighash
    const scriptCode = Buffer.concat([
      Buffer.from([0x76, 0xa9, 0x14]),  // OP_DUP OP_HASH160 PUSH20
      bitcoin.crypto.hash160(pubkey),
      Buffer.from([0x88, 0xac])         // OP_EQUALVERIFY OP_CHECKSIG
    ]);

    const witnessHash = toSignTx.hashForWitnessV0(
      0,
      scriptCode,
      BigInt(0),
      bitcoin.Transaction.SIGHASH_ALL
    );

    // Step 5: Sign the Hash using Enclave
    // We use generic signing capability of the Enclave
    // For Native: We'll need to support raw hash signing or pass the hash as "payload"
    // The requestEnclaveSignature function handles 'Mainnet' generic signing by hashing the payload.
    // BUT we already have the hash. We shouldn't double hash.
    // We need a way to pass "PRE_HASHED" payload.

    // HACK: For now, if we pass a Buffer/Hex as payload to our Native implementation,
    // it usually hashes it again (sha256).
    // ECDSA signing requires a 32-byte hash.
    // If we use `signNative` directly in `requestEnclaveSignature`, it takes `messageHash`.

    // We'll modify `requestEnclaveSignature` to accept `preHashed: true` or handle generic hex payload
    // correctly. Looking at `requestEnclaveSignature` implementation:
    // It does `const hash = Buffer.from(bitcoin.crypto.sha256(cx)).toString("hex");`

    // We need to bypass that hash if it's already a sighash.
    // Let's invoke signNative directly if on Native, or use a modified request flow.

    let signatureHex: string;

    if (Capacitor.isNativePlatform()) {
        const res = await signNative({
            vault: vaultOrSeed as string,
            pin,
            path: "m/84'/0'/0'/0/0",
            messageHash: Buffer.from(witnessHash).toString('hex'),
            network: 'mainnet'
        });
        signatureHex = res.signature;
    } else {
        // JS Fallback (using cached seed bytes)
        // We reuse the logic from requestEnclaveSignature but we need the root first
        // Re-deriving root here is inefficient but safe for now.
        // Actually, we can just call a helper or use generic sign logic.

        // Simulating access to seed (which is vaultOrSeed in JS path)
        if (typeof vaultOrSeed === 'string') throw new Error("BIP-322 JS fallback requires seed bytes");

        const root = bip32.fromSeed(Buffer.from(vaultOrSeed));
        const child = root.derivePath("m/84'/0'/0'/0/0");
        signatureHex = Buffer.from(child.sign(Buffer.from(witnessHash))).toString('hex');

        // Wipe seed copy
        // vaultOrSeed.fill(0); // Only if we own it? No, caller owns it.
    }

    const signature = Buffer.from(signatureHex, 'hex');
    const derSig = bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL);

    // Step 6: Serialize witness stack [signature, pubkey]
    const witnessStack = [derSig, pubkey];
=======
export const signBip322Message = async (
    message: string,
    vaultOrSeed: string | Uint8Array,
    pin?: string,
    scriptType: 'P2WPKH' | 'P2TR' = 'P2WPKH'
): Promise<string> => {
    // 1. Get Pubkey from Enclave
    const path = scriptType === 'P2TR' ? "m/86'/0'/0'/0/0" : "m/84'/0'/0'/0/0";

    let pubkey: Buffer;
    if (Capacitor.isNativePlatform()) {
        const res = await signNative({
            vault: vaultOrSeed as string,
            pin,
            path,
            messageHash: "DUMMY_HASH_FOR_PUBKEY",
            network: 'mainnet'
        });
        pubkey = Buffer.from(res.pubkey, 'hex');
    } else {
        if (typeof vaultOrSeed === 'string') throw new Error("BIP-322 JS fallback requires seed bytes");
        const root = bip32.fromSeed(Buffer.from(vaultOrSeed));
        const child = root.derivePath(path);
        pubkey = Buffer.from(child.publicKey);
    }

    // Step 1: Build the message hash per BIP-322
    const tag = bitcoin.crypto.sha256(Buffer.from('BIP0322-signed-message'));
    const msgBuf = Buffer.from(message, 'utf8');
    const taggedHash = bitcoin.crypto.sha256(Buffer.concat([tag, tag, msgBuf]));

    // Step 2: Build virtual "to_spend" transaction
    const toSpendScriptSig = Buffer.concat([
      Buffer.from([0x00, 0x20]),  // OP_0 PUSH32
      taggedHash
    ]);

    let output: Buffer;
    if (scriptType === 'P2TR') {
        const p2tr = bitcoin.payments.p2tr({ internalPubkey: pubkey.subarray(1, 33), network: bitcoin.networks.bitcoin });
        if (!p2tr.output) throw new Error('BIP-322: Failed to create P2TR output');
        output = p2tr.output;
    } else {
        const p2wpkh = bitcoin.payments.p2wpkh({ pubkey, network: bitcoin.networks.bitcoin });
        if (!p2wpkh.output) throw new Error('BIP-322: Failed to create P2WPKH output');
        output = p2wpkh.output;
    }

    const toSpendTx = new bitcoin.Transaction();
    toSpendTx.version = 0;
    toSpendTx.locktime = 0;
    toSpendTx.addInput(Buffer.alloc(32, 0), 0xFFFFFFFF, 0, toSpendScriptSig);
    toSpendTx.addOutput(output, BigInt(0));

    // Step 3: Build "to_sign" transaction
    const toSignTx = new bitcoin.Transaction();
    toSignTx.version = 0;
    toSignTx.locktime = 0;
    toSignTx.addInput(toSpendTx.getHash(), 0, 0);
    toSignTx.addOutput(Buffer.from([0x6a]), BigInt(0)); // OP_RETURN

    // Step 4: Calculate Sighash
    let sighash: Buffer;
    if (scriptType === 'P2TR') {
        // Taproot sign-to-spend
        sighash = toSignTx.hashForTaprootSignature(
            0,
            [output],
            bitcoin.Transaction.SIGHASH_DEFAULT
        );
    } else {
        const scriptCode = Buffer.concat([
            Buffer.from([0x76, 0xa9, 0x14]),  // OP_DUP OP_HASH160 PUSH20
            bitcoin.crypto.hash160(pubkey),
            Buffer.from([0x88, 0xac])         // OP_EQUALVERIFY OP_CHECKSIG
        ]);
        sighash = toSignTx.hashForWitnessV0(
            0,
            scriptCode,
            BigInt(0),
            bitcoin.Transaction.SIGHASH_ALL
        );
    }

    // Step 5: Sign the Hash using Enclave
    let signatureHex: string;
    if (Capacitor.isNativePlatform()) {
        const res = await signNative({
            vault: vaultOrSeed as string,
            pin,
            path,
            messageHash: sighash.toString('hex'),
            network: 'mainnet'
        });
        signatureHex = res.signature;
    } else {
        const root = bip32.fromSeed(Buffer.from(vaultOrSeed as Uint8Array));
        const child = root.derivePath(path);
        // Note: For Taproot, we should technically use Schnorr sign.
        // bitcoinjs-lib's sign() for BIP32 is ECDSA.
        // If scriptType is P2TR, we need a Schnorr signer.
        if (scriptType === 'P2TR') {
            // This is a simplified fallback; real implementation should use ecc.signSchnorr
            throw new Error("BIP-322 Taproot signing in JS requires ecc.signSchnorr");
        }
        signatureHex = Buffer.from(child.sign(sighash)).toString('hex');
    }

    // Step 6: Serialize witness stack
    let witnessStack: Buffer[];
    if (scriptType === 'P2TR') {
        // Schnorr signature (usually 64 bytes)
        witnessStack = [Buffer.from(signatureHex, 'hex')];
    } else {
        const signature = Buffer.from(signatureHex, 'hex');
        const derSig = bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL);
        witnessStack = [derSig, pubkey];
    }
>>>>>>> REPLACE
