<<<<<<< SEARCH
import * as bip39 from 'bip39';
import BIP32Factory from 'bip32';
import * as ecc from 'tiny-secp256k1';
import { Buffer } from 'buffer';
import { Capacitor } from '@capacitor/core';
import { signNative, signBatchNative } from './enclave-storage';
import { getPsbtSighashes, finalizePsbtWithSigs, signPsbtBase64WithSeed, signPsbtBase64WithSeedReturnBase64 } from './psbt';
import { SignRequest, SignResult } from './signer';

const bip32 = BIP32Factory(ecc);
import * as bitcoin from 'bitcoinjs-lib';
=======
import * as bip39 from 'bip39';
import BIP32Factory from 'bip32';
import * as ecc from 'tiny-secp256k1';
import { Buffer } from 'buffer';
import { Capacitor } from '@capacitor/core';
import { signNative, signBatchNative } from './enclave-storage';
import { getPsbtSighashes, finalizePsbtWithSigs, signPsbtBase64WithSeed, signPsbtBase64WithSeedReturnBase64 } from './psbt';
import { SignRequest, SignResult } from './signer';
import { workerManager } from './worker-manager';

const bip32 = BIP32Factory(ecc);
import * as bitcoin from 'bitcoinjs-lib';
>>>>>>> REPLACE
<<<<<<< SEARCH
  // --- WEB / LEGACY PATH ---
  const seedBytes =
    typeof seedOrVault === "string"
      ? await bip39.mnemonicToSeed(seedOrVault) // Fallback if string passed but no PIN/Native (Should not happen flow-wise) or if passing mnemonic directly
      : (seedOrVault as Uint8Array);

  try {
    let root;
    if (seedBytes) {
      root = bip32.fromSeed(Buffer.from(seedBytes));
    }

    let signature = "";
    let pubkey = "";
    let broadcastHex = "";
    let psbtBase64: string | undefined;

    if (request.layer === "Mainnet" && root) {
      const coin = request.payload?.network === "mainnet" ? 0 : 1;
      const child = root.derivePath();
      pubkey = Buffer.from(child.publicKey).toString("hex");
      if (request.payload && request.payload.psbt && request.payload.network) {
=======
  // --- WEB / LEGACY PATH ---
  const seedBytes =
    typeof seedOrVault === "string"
      ? await workerManager.deriveSeed(seedOrVault)
      : (seedOrVault as Uint8Array);

  try {
    let signature = "";
    let pubkey = "";
    let broadcastHex = "";
    let psbtBase64: string | undefined;

    if (request.layer === "Mainnet" && seedBytes) {
      const coin = request.payload?.network === "mainnet" ? 0 : 1;
      const path = ;
      const derived = await workerManager.derivePath(seedBytes, path);
      pubkey = derived.publicKey;

      if (request.payload && request.payload.psbt && request.payload.network) {
>>>>>>> REPLACE
<<<<<<< SEARCH
        signature = Buffer.from(
          bitcoin.crypto.sha256(Buffer.from(broadcastHex, "hex")),
        ).toString("hex");
        broadcastHex = "";
      }
    } else if (request.layer === "Stacks" && root) {
      const child = root.derivePath("m/44'/5757'/0'/0/0");
      pubkey = Buffer.from(child.publicKey).toString("hex");
      // Stacks signing logic
      const stacksHash = Buffer.from(bitcoin.crypto.sha256(Buffer.from("stacks-sig")));
      signature = Buffer.from(child.sign(stacksHash)).toString(
        "hex",
      );
    }
=======
        signature = Buffer.from(
          bitcoin.crypto.sha256(Buffer.from(broadcastHex, "hex")),
        ).toString("hex");
        broadcastHex = "";
      }
    } else if (request.layer === "Stacks" && seedBytes) {
      const path = "m/44'/5757'/0'/0/0";
      const derived = await workerManager.derivePath(seedBytes, path);
      pubkey = derived.publicKey;

      // For Stacks signing, we still need a local key if it's WEB path
      // but the worker already gave us the private key if available
      if (derived.privateKey) {
          const child = bip32.fromPrivateKey(Buffer.from(derived.privateKey, 'hex'), Buffer.alloc(32)); // Dummy chaincode
          const stacksHash = Buffer.from(bitcoin.crypto.sha256(Buffer.from("stacks-sig")));
          signature = Buffer.from(child.sign(stacksHash)).toString("hex");
      }
    }
>>>>>>> REPLACE
